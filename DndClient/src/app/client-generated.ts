/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class LoginService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5000";
    }

    login(value: UsernamePw): Observable<Token> {
        let url_ = this.baseUrl + "/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<Token>><any>_observableThrow(e);
                }
            } else
                return <Observable<Token>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<Token> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Token.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Token>(<any>null);
    }

    register(value: Register): Observable<Token> {
        let url_ = this.baseUrl + "/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<Token>><any>_observableThrow(e);
                }
            } else
                return <Observable<Token>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<Token> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Token.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Token>(<any>null);
    }
}

@Injectable()
export class SheetService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5000";
    }

    getSheets(username: string | null): Observable<string[]> {
        let url_ = this.baseUrl + "/user/{username}/sheets";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSheets(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSheets(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSheets(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    getSheet(username: string | null, sheetname: string | null): Observable<CharacterSheet> {
        let url_ = this.baseUrl + "/user/{username}/sheet/{sheetname}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        if (sheetname === undefined || sheetname === null)
            throw new Error("The parameter 'sheetname' must be defined.");
        url_ = url_.replace("{sheetname}", encodeURIComponent("" + sheetname));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSheet(<any>response_);
                } catch (e) {
                    return <Observable<CharacterSheet>><any>_observableThrow(e);
                }
            } else
                return <Observable<CharacterSheet>><any>_observableThrow(response_);
        }));
    }

    protected processGetSheet(response: HttpResponseBase): Observable<CharacterSheet> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CharacterSheet.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CharacterSheet>(<any>null);
    }

    updateSheet(username: string | null, sheetname: string | null, sheet: CharacterSheet): Observable<string[]> {
        let url_ = this.baseUrl + "/user/{username}/sheet/{sheetname}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        if (sheetname === undefined || sheetname === null)
            throw new Error("The parameter 'sheetname' must be defined.");
        url_ = url_.replace("{sheetname}", encodeURIComponent("" + sheetname));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sheet);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSheet(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSheet(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    deleteSheet(username: string | null, sheetname: string | null): Observable<string[]> {
        let url_ = this.baseUrl + "/user/{username}/sheet/{sheetname}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        if (sheetname === undefined || sheetname === null)
            throw new Error("The parameter 'sheetname' must be defined.");
        url_ = url_.replace("{sheetname}", encodeURIComponent("" + sheetname));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteSheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteSheet(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteSheet(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }

    newSheet(username: string | null, sheet: CharacterSheet): Observable<CharacterSheet2> {
        let url_ = this.baseUrl + "/user/{username}/newsheet";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sheet);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewSheet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewSheet(<any>response_);
                } catch (e) {
                    return <Observable<CharacterSheet2>><any>_observableThrow(e);
                }
            } else
                return <Observable<CharacterSheet2>><any>_observableThrow(response_);
        }));
    }

    protected processNewSheet(response: HttpResponseBase): Observable<CharacterSheet2> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CharacterSheet2.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CharacterSheet2>(<any>null);
    }
}

@Injectable()
export class UserService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5000";
    }

    addFriend(user: string, friend: string): void {
        this.http.post(this.baseUrl + "/user/" + user + "/addfriend/" + friend, "").subscribe( () => console.log("success"));
    }

    getUser(name: string | null): Observable<ApplicationUserHeader> {
        let url_ = this.baseUrl + "/user/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationUserHeader>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationUserHeader>><any>_observableThrow(response_);
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<ApplicationUserHeader> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUserHeader.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUserHeader>(<any>null);
    }

    updateUser(name: string | null, newuser: ApplicationUserHeader): Observable<ApplicationUserHeader> {
        let url_ = this.baseUrl + "/user/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newuser);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationUserHeader>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationUserHeader>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<ApplicationUserHeader> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationUserHeader.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationUserHeader>(<any>null);
    }
}

export class Token implements IToken {
    token?: string | undefined;

    constructor(data?: IToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): Token {
        data = typeof data === 'object' ? data : {};
        let result = new Token();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data; 
    }
}

export interface IToken {
    token?: string | undefined;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        this.extensions![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    data["extensions"][key] = this.extensions[key];
            }
        }
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

export class UsernamePw implements IUsernamePw {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: IUsernamePw) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UsernamePw {
        data = typeof data === 'object' ? data : {};
        let result = new UsernamePw();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface IUsernamePw {
    userName?: string | undefined;
    password?: string | undefined;
}

export class Register implements IRegister {
    userName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;

    constructor(data?: IRegister) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): Register {
        data = typeof data === 'object' ? data : {};
        let result = new Register();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }
}

export interface IRegister {
    userName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
}

export class CharacterSheet implements ICharacterSheet {
    featureSkills?: FeatureSkill[] | undefined;
    weapons?: Weapon[] | undefined;
    spells?: Spell[] | undefined;
    characterName?: string | undefined;
    class?: string | undefined;
    level?: number | undefined;
    proficiency?: number | undefined;
    inspiration?: number | undefined;
    ac?: number | undefined;
    initiative?: number | undefined;
    speed?: number | undefined;
    hpMax?: number | undefined;
    currHp?: number | undefined;
    tempHp?: number | undefined;
    hitDice?: number | undefined;
    deathSaveSuccess?: number | undefined;
    deathSaveFail?: number | undefined;
    passiveWisdom?: number | undefined;
    proficienciesLanguages?: string | undefined;
    notes?: string | undefined;
    gold?: number | undefined;
    silver?: number | undefined;
    copper?: number | undefined;
    equipment?: string | undefined;
    str?: number | undefined;
    dex?: number | undefined;
    con?: number | undefined;
    int?: number | undefined;
    wis?: number | undefined;
    cha?: number | undefined;
    strSave?: number | undefined;
    dexSave?: number | undefined;
    conSave?: number | undefined;
    intSave?: number | undefined;
    wisSave?: number | undefined;
    chaSave?: number | undefined;
    acrobatics?: number | undefined;
    animalHandling?: number | undefined;
    arcana?: number | undefined;
    athletics?: number | undefined;
    deception?: number | undefined;
    history?: number | undefined;
    insight?: number | undefined;
    intimidation?: number | undefined;
    investigation?: number | undefined;
    nature?: number | undefined;
    medicine?: number | undefined;
    perception?: number | undefined;
    performance?: number | undefined;
    persuasion?: number | undefined;
    religion?: number | undefined;
    sleightOfHand?: number | undefined;
    stealth?: number | undefined;
    survival?: number | undefined;
    background?: string | undefined;
    race?: string | undefined;
    alignment?: string | undefined;
    xp?: string | undefined;
    age?: string | undefined;
    height?: string | undefined;
    weight?: string | undefined;
    eyes?: string | undefined;
    skin?: string | undefined;
    hair?: string | undefined;
    personality?: string | undefined;
    ideals?: string | undefined;
    bonds?: string | undefined;
    flaws?: string | undefined;
    spellAbility?: string | undefined;
    spellSaveDC?: number | undefined;
    spellAtkBonus?: number | undefined;

    constructor(data?: ICharacterSheet) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["featureSkills"])) {
                this.featureSkills = [] as any;
                for (let item of _data["featureSkills"])
                    this.featureSkills!.push(FeatureSkill.fromJS(item));
            }
            if (Array.isArray(_data["weapons"])) {
                this.weapons = [] as any;
                for (let item of _data["weapons"])
                    this.weapons!.push(Weapon.fromJS(item));
            }
            if (Array.isArray(_data["spells"])) {
                this.spells = [] as any;
                for (let item of _data["spells"])
                    this.spells!.push(Spell.fromJS(item));
            }
            this.characterName = _data["characterName"];
            this.class = _data["class"];
            this.level = _data["level"];
            this.proficiency = _data["proficiency"];
            this.inspiration = _data["inspiration"];
            this.ac = _data["ac"];
            this.initiative = _data["initiative"];
            this.speed = _data["speed"];
            this.hpMax = _data["hpMax"];
            this.currHp = _data["currHp"];
            this.tempHp = _data["tempHp"];
            this.hitDice = _data["hitDice"];
            this.deathSaveSuccess = _data["deathSaveSuccess"];
            this.deathSaveFail = _data["deathSaveFail"];
            this.passiveWisdom = _data["passiveWisdom"];
            this.proficienciesLanguages = _data["proficienciesLanguages"];
            this.notes = _data["notes"];
            this.gold = _data["gold"];
            this.silver = _data["silver"];
            this.copper = _data["copper"];
            this.equipment = _data["equipment"];
            this.str = _data["str"];
            this.dex = _data["dex"];
            this.con = _data["con"];
            this.int = _data["int"];
            this.wis = _data["wis"];
            this.cha = _data["cha"];
            this.strSave = _data["strSave"];
            this.dexSave = _data["dexSave"];
            this.conSave = _data["conSave"];
            this.intSave = _data["intSave"];
            this.wisSave = _data["wisSave"];
            this.chaSave = _data["chaSave"];
            this.acrobatics = _data["acrobatics"];
            this.animalHandling = _data["animalHandling"];
            this.arcana = _data["arcana"];
            this.athletics = _data["athletics"];
            this.deception = _data["deception"];
            this.history = _data["history"];
            this.insight = _data["insight"];
            this.intimidation = _data["intimidation"];
            this.investigation = _data["investigation"];
            this.nature = _data["nature"];
            this.medicine = _data["medicine"];
            this.perception = _data["perception"];
            this.performance = _data["performance"];
            this.persuasion = _data["persuasion"];
            this.religion = _data["religion"];
            this.sleightOfHand = _data["sleightOfHand"];
            this.stealth = _data["stealth"];
            this.survival = _data["survival"];
            this.background = _data["background"];
            this.race = _data["race"];
            this.alignment = _data["alignment"];
            this.xp = _data["xp"];
            this.age = _data["age"];
            this.height = _data["height"];
            this.weight = _data["weight"];
            this.eyes = _data["eyes"];
            this.skin = _data["skin"];
            this.hair = _data["hair"];
            this.personality = _data["personality"];
            this.ideals = _data["ideals"];
            this.bonds = _data["bonds"];
            this.flaws = _data["flaws"];
            this.spellAbility = _data["spellAbility"];
            this.spellSaveDC = _data["spellSaveDC"];
            this.spellAtkBonus = _data["spellAtkBonus"];
        }
    }

    static fromJS(data: any): CharacterSheet {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterSheet();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.featureSkills)) {
            data["featureSkills"] = [];
            for (let item of this.featureSkills)
                data["featureSkills"].push(item.toJSON());
        }
        if (Array.isArray(this.weapons)) {
            data["weapons"] = [];
            for (let item of this.weapons)
                data["weapons"].push(item.toJSON());
        }
        if (Array.isArray(this.spells)) {
            data["spells"] = [];
            for (let item of this.spells)
                data["spells"].push(item.toJSON());
        }
        data["characterName"] = this.characterName;
        data["class"] = this.class;
        data["level"] = this.level;
        data["proficiency"] = this.proficiency;
        data["inspiration"] = this.inspiration;
        data["ac"] = this.ac;
        data["initiative"] = this.initiative;
        data["speed"] = this.speed;
        data["hpMax"] = this.hpMax;
        data["currHp"] = this.currHp;
        data["tempHp"] = this.tempHp;
        data["hitDice"] = this.hitDice;
        data["deathSaveSuccess"] = this.deathSaveSuccess;
        data["deathSaveFail"] = this.deathSaveFail;
        data["passiveWisdom"] = this.passiveWisdom;
        data["proficienciesLanguages"] = this.proficienciesLanguages;
        data["notes"] = this.notes;
        data["gold"] = this.gold;
        data["silver"] = this.silver;
        data["copper"] = this.copper;
        data["equipment"] = this.equipment;
        data["str"] = this.str;
        data["dex"] = this.dex;
        data["con"] = this.con;
        data["int"] = this.int;
        data["wis"] = this.wis;
        data["cha"] = this.cha;
        data["strSave"] = this.strSave;
        data["dexSave"] = this.dexSave;
        data["conSave"] = this.conSave;
        data["intSave"] = this.intSave;
        data["wisSave"] = this.wisSave;
        data["chaSave"] = this.chaSave;
        data["acrobatics"] = this.acrobatics;
        data["animalHandling"] = this.animalHandling;
        data["arcana"] = this.arcana;
        data["athletics"] = this.athletics;
        data["deception"] = this.deception;
        data["history"] = this.history;
        data["insight"] = this.insight;
        data["intimidation"] = this.intimidation;
        data["investigation"] = this.investigation;
        data["nature"] = this.nature;
        data["medicine"] = this.medicine;
        data["perception"] = this.perception;
        data["performance"] = this.performance;
        data["persuasion"] = this.persuasion;
        data["religion"] = this.religion;
        data["sleightOfHand"] = this.sleightOfHand;
        data["stealth"] = this.stealth;
        data["survival"] = this.survival;
        data["background"] = this.background;
        data["race"] = this.race;
        data["alignment"] = this.alignment;
        data["xp"] = this.xp;
        data["age"] = this.age;
        data["height"] = this.height;
        data["weight"] = this.weight;
        data["eyes"] = this.eyes;
        data["skin"] = this.skin;
        data["hair"] = this.hair;
        data["personality"] = this.personality;
        data["ideals"] = this.ideals;
        data["bonds"] = this.bonds;
        data["flaws"] = this.flaws;
        data["spellAbility"] = this.spellAbility;
        data["spellSaveDC"] = this.spellSaveDC;
        data["spellAtkBonus"] = this.spellAtkBonus;
        return data; 
    }
}

export interface ICharacterSheet {
    featureSkills?: FeatureSkill[] | undefined;
    weapons?: Weapon[] | undefined;
    spells?: Spell[] | undefined;
    characterName?: string | undefined;
    class?: string | undefined;
    level?: number | undefined;
    proficiency?: number | undefined;
    inspiration?: number | undefined;
    ac?: number | undefined;
    initiative?: number | undefined;
    speed?: number | undefined;
    hpMax?: number | undefined;
    currHp?: number | undefined;
    tempHp?: number | undefined;
    hitDice?: number | undefined;
    deathSaveSuccess?: number | undefined;
    deathSaveFail?: number | undefined;
    passiveWisdom?: number | undefined;
    proficienciesLanguages?: string | undefined;
    notes?: string | undefined;
    gold?: number | undefined;
    silver?: number | undefined;
    copper?: number | undefined;
    equipment?: string | undefined;
    str?: number | undefined;
    dex?: number | undefined;
    con?: number | undefined;
    int?: number | undefined;
    wis?: number | undefined;
    cha?: number | undefined;
    strSave?: number | undefined;
    dexSave?: number | undefined;
    conSave?: number | undefined;
    intSave?: number | undefined;
    wisSave?: number | undefined;
    chaSave?: number | undefined;
    acrobatics?: number | undefined;
    animalHandling?: number | undefined;
    arcana?: number | undefined;
    athletics?: number | undefined;
    deception?: number | undefined;
    history?: number | undefined;
    insight?: number | undefined;
    intimidation?: number | undefined;
    investigation?: number | undefined;
    nature?: number | undefined;
    medicine?: number | undefined;
    perception?: number | undefined;
    performance?: number | undefined;
    persuasion?: number | undefined;
    religion?: number | undefined;
    sleightOfHand?: number | undefined;
    stealth?: number | undefined;
    survival?: number | undefined;
    background?: string | undefined;
    race?: string | undefined;
    alignment?: string | undefined;
    xp?: string | undefined;
    age?: string | undefined;
    height?: string | undefined;
    weight?: string | undefined;
    eyes?: string | undefined;
    skin?: string | undefined;
    hair?: string | undefined;
    personality?: string | undefined;
    ideals?: string | undefined;
    bonds?: string | undefined;
    flaws?: string | undefined;
    spellAbility?: string | undefined;
    spellSaveDC?: number | undefined;
    spellAtkBonus?: number | undefined;
}

export class FeatureSkill implements IFeatureSkill {
    name?: string | undefined;
    description?: string | undefined;
    level?: number | undefined;

    constructor(data?: IFeatureSkill) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.level = _data["level"];
        }
    }

    static fromJS(data: any): FeatureSkill {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureSkill();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["level"] = this.level;
        return data; 
    }
}

export interface IFeatureSkill {
    name?: string | undefined;
    description?: string | undefined;
    level?: number | undefined;
}

export class Weapon implements IWeapon {
    name?: string | undefined;
    atkBonus?: number | undefined;
    dmg?: number | undefined;
    type?: string | undefined;

    constructor(data?: IWeapon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.atkBonus = _data["atkBonus"];
            this.dmg = _data["dmg"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Weapon {
        data = typeof data === 'object' ? data : {};
        let result = new Weapon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["atkBonus"] = this.atkBonus;
        data["dmg"] = this.dmg;
        data["type"] = this.type;
        return data; 
    }
}

export interface IWeapon {
    name?: string | undefined;
    atkBonus?: number | undefined;
    dmg?: number | undefined;
    type?: string | undefined;
}

export class Spell implements ISpell {
    name?: string | undefined;
    level?: number | undefined;
    school?: string | undefined;
    castingTime?: string | undefined;
    range?: string | undefined;
    components?: string | undefined;
    duration?: string | undefined;
    description?: string | undefined;
    higherLevels?: string | undefined;

    constructor(data?: ISpell) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.level = _data["level"];
            this.school = _data["school"];
            this.castingTime = _data["castingTime"];
            this.range = _data["range"];
            this.components = _data["components"];
            this.duration = _data["duration"];
            this.description = _data["description"];
            this.higherLevels = _data["higherLevels"];
        }
    }

    static fromJS(data: any): Spell {
        data = typeof data === 'object' ? data : {};
        let result = new Spell();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["level"] = this.level;
        data["school"] = this.school;
        data["castingTime"] = this.castingTime;
        data["range"] = this.range;
        data["components"] = this.components;
        data["duration"] = this.duration;
        data["description"] = this.description;
        data["higherLevels"] = this.higherLevels;
        return data; 
    }
}

export interface ISpell {
    name?: string | undefined;
    level?: number | undefined;
    school?: string | undefined;
    castingTime?: string | undefined;
    range?: string | undefined;
    components?: string | undefined;
    duration?: string | undefined;
    description?: string | undefined;
    higherLevels?: string | undefined;
}

export class CharacterSheet2 implements ICharacterSheet2 {
    id!: number;
    featureSkills?: FeatureSkill2[] | undefined;
    weapons?: Weapon2[] | undefined;
    spells?: Spell2[] | undefined;
    characterName!: string;
    class?: string | undefined;
    level?: number | undefined;
    proficiency?: number | undefined;
    inspiration?: number | undefined;
    ac?: number | undefined;
    initiative?: number | undefined;
    speed?: number | undefined;
    hpMax?: number | undefined;
    currHp?: number | undefined;
    tempHp?: number | undefined;
    hitDice?: number | undefined;
    deathSaveSuccess?: number | undefined;
    deathSaveFail?: number | undefined;
    passiveWisdom?: number | undefined;
    proficienciesLanguages?: string | undefined;
    notes?: string | undefined;
    gold?: number | undefined;
    silver?: number | undefined;
    copper?: number | undefined;
    equipment?: string | undefined;
    str?: number | undefined;
    dex?: number | undefined;
    con?: number | undefined;
    int?: number | undefined;
    wis?: number | undefined;
    cha?: number | undefined;
    strSave?: number | undefined;
    dexSave?: number | undefined;
    conSave?: number | undefined;
    intSave?: number | undefined;
    wisSave?: number | undefined;
    chaSave?: number | undefined;
    acrobatics?: number | undefined;
    animalHandling?: number | undefined;
    arcana?: number | undefined;
    athletics?: number | undefined;
    deception?: number | undefined;
    history?: number | undefined;
    insight?: number | undefined;
    intimidation?: number | undefined;
    investigation?: number | undefined;
    nature?: number | undefined;
    medicine?: number | undefined;
    perception?: number | undefined;
    performance?: number | undefined;
    persuasion?: number | undefined;
    religion?: number | undefined;
    sleightOfHand?: number | undefined;
    stealth?: number | undefined;
    survival?: number | undefined;
    background?: string | undefined;
    race?: string | undefined;
    alignment?: string | undefined;
    xp?: string | undefined;
    age?: string | undefined;
    height?: string | undefined;
    weight?: string | undefined;
    eyes?: string | undefined;
    skin?: string | undefined;
    hair?: string | undefined;
    personality?: string | undefined;
    ideals?: string | undefined;
    bonds?: string | undefined;
    flaws?: string | undefined;
    spellAbility?: string | undefined;
    spellSaveDC?: number | undefined;
    spellAtkBonus?: number | undefined;

    constructor(data?: ICharacterSheet2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["featureSkills"])) {
                this.featureSkills = [] as any;
                for (let item of _data["featureSkills"])
                    this.featureSkills!.push(FeatureSkill2.fromJS(item));
            }
            if (Array.isArray(_data["weapons"])) {
                this.weapons = [] as any;
                for (let item of _data["weapons"])
                    this.weapons!.push(Weapon2.fromJS(item));
            }
            if (Array.isArray(_data["spells"])) {
                this.spells = [] as any;
                for (let item of _data["spells"])
                    this.spells!.push(Spell2.fromJS(item));
            }
            this.characterName = _data["characterName"];
            this.class = _data["class"];
            this.level = _data["level"];
            this.proficiency = _data["proficiency"];
            this.inspiration = _data["inspiration"];
            this.ac = _data["ac"];
            this.initiative = _data["initiative"];
            this.speed = _data["speed"];
            this.hpMax = _data["hpMax"];
            this.currHp = _data["currHp"];
            this.tempHp = _data["tempHp"];
            this.hitDice = _data["hitDice"];
            this.deathSaveSuccess = _data["deathSaveSuccess"];
            this.deathSaveFail = _data["deathSaveFail"];
            this.passiveWisdom = _data["passiveWisdom"];
            this.proficienciesLanguages = _data["proficienciesLanguages"];
            this.notes = _data["notes"];
            this.gold = _data["gold"];
            this.silver = _data["silver"];
            this.copper = _data["copper"];
            this.equipment = _data["equipment"];
            this.str = _data["str"];
            this.dex = _data["dex"];
            this.con = _data["con"];
            this.int = _data["int"];
            this.wis = _data["wis"];
            this.cha = _data["cha"];
            this.strSave = _data["strSave"];
            this.dexSave = _data["dexSave"];
            this.conSave = _data["conSave"];
            this.intSave = _data["intSave"];
            this.wisSave = _data["wisSave"];
            this.chaSave = _data["chaSave"];
            this.acrobatics = _data["acrobatics"];
            this.animalHandling = _data["animalHandling"];
            this.arcana = _data["arcana"];
            this.athletics = _data["athletics"];
            this.deception = _data["deception"];
            this.history = _data["history"];
            this.insight = _data["insight"];
            this.intimidation = _data["intimidation"];
            this.investigation = _data["investigation"];
            this.nature = _data["nature"];
            this.medicine = _data["medicine"];
            this.perception = _data["perception"];
            this.performance = _data["performance"];
            this.persuasion = _data["persuasion"];
            this.religion = _data["religion"];
            this.sleightOfHand = _data["sleightOfHand"];
            this.stealth = _data["stealth"];
            this.survival = _data["survival"];
            this.background = _data["background"];
            this.race = _data["race"];
            this.alignment = _data["alignment"];
            this.xp = _data["xp"];
            this.age = _data["age"];
            this.height = _data["height"];
            this.weight = _data["weight"];
            this.eyes = _data["eyes"];
            this.skin = _data["skin"];
            this.hair = _data["hair"];
            this.personality = _data["personality"];
            this.ideals = _data["ideals"];
            this.bonds = _data["bonds"];
            this.flaws = _data["flaws"];
            this.spellAbility = _data["spellAbility"];
            this.spellSaveDC = _data["spellSaveDC"];
            this.spellAtkBonus = _data["spellAtkBonus"];
        }
    }

    static fromJS(data: any): CharacterSheet2 {
        data = typeof data === 'object' ? data : {};
        let result = new CharacterSheet2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.featureSkills)) {
            data["featureSkills"] = [];
            for (let item of this.featureSkills)
                data["featureSkills"].push(item.toJSON());
        }
        if (Array.isArray(this.weapons)) {
            data["weapons"] = [];
            for (let item of this.weapons)
                data["weapons"].push(item.toJSON());
        }
        if (Array.isArray(this.spells)) {
            data["spells"] = [];
            for (let item of this.spells)
                data["spells"].push(item.toJSON());
        }
        data["characterName"] = this.characterName;
        data["class"] = this.class;
        data["level"] = this.level;
        data["proficiency"] = this.proficiency;
        data["inspiration"] = this.inspiration;
        data["ac"] = this.ac;
        data["initiative"] = this.initiative;
        data["speed"] = this.speed;
        data["hpMax"] = this.hpMax;
        data["currHp"] = this.currHp;
        data["tempHp"] = this.tempHp;
        data["hitDice"] = this.hitDice;
        data["deathSaveSuccess"] = this.deathSaveSuccess;
        data["deathSaveFail"] = this.deathSaveFail;
        data["passiveWisdom"] = this.passiveWisdom;
        data["proficienciesLanguages"] = this.proficienciesLanguages;
        data["notes"] = this.notes;
        data["gold"] = this.gold;
        data["silver"] = this.silver;
        data["copper"] = this.copper;
        data["equipment"] = this.equipment;
        data["str"] = this.str;
        data["dex"] = this.dex;
        data["con"] = this.con;
        data["int"] = this.int;
        data["wis"] = this.wis;
        data["cha"] = this.cha;
        data["strSave"] = this.strSave;
        data["dexSave"] = this.dexSave;
        data["conSave"] = this.conSave;
        data["intSave"] = this.intSave;
        data["wisSave"] = this.wisSave;
        data["chaSave"] = this.chaSave;
        data["acrobatics"] = this.acrobatics;
        data["animalHandling"] = this.animalHandling;
        data["arcana"] = this.arcana;
        data["athletics"] = this.athletics;
        data["deception"] = this.deception;
        data["history"] = this.history;
        data["insight"] = this.insight;
        data["intimidation"] = this.intimidation;
        data["investigation"] = this.investigation;
        data["nature"] = this.nature;
        data["medicine"] = this.medicine;
        data["perception"] = this.perception;
        data["performance"] = this.performance;
        data["persuasion"] = this.persuasion;
        data["religion"] = this.religion;
        data["sleightOfHand"] = this.sleightOfHand;
        data["stealth"] = this.stealth;
        data["survival"] = this.survival;
        data["background"] = this.background;
        data["race"] = this.race;
        data["alignment"] = this.alignment;
        data["xp"] = this.xp;
        data["age"] = this.age;
        data["height"] = this.height;
        data["weight"] = this.weight;
        data["eyes"] = this.eyes;
        data["skin"] = this.skin;
        data["hair"] = this.hair;
        data["personality"] = this.personality;
        data["ideals"] = this.ideals;
        data["bonds"] = this.bonds;
        data["flaws"] = this.flaws;
        data["spellAbility"] = this.spellAbility;
        data["spellSaveDC"] = this.spellSaveDC;
        data["spellAtkBonus"] = this.spellAtkBonus;
        return data; 
    }
}

export interface ICharacterSheet2 {
    id: number;
    featureSkills?: FeatureSkill2[] | undefined;
    weapons?: Weapon2[] | undefined;
    spells?: Spell2[] | undefined;
    characterName: string;
    class?: string | undefined;
    level?: number | undefined;
    proficiency?: number | undefined;
    inspiration?: number | undefined;
    ac?: number | undefined;
    initiative?: number | undefined;
    speed?: number | undefined;
    hpMax?: number | undefined;
    currHp?: number | undefined;
    tempHp?: number | undefined;
    hitDice?: number | undefined;
    deathSaveSuccess?: number | undefined;
    deathSaveFail?: number | undefined;
    passiveWisdom?: number | undefined;
    proficienciesLanguages?: string | undefined;
    notes?: string | undefined;
    gold?: number | undefined;
    silver?: number | undefined;
    copper?: number | undefined;
    equipment?: string | undefined;
    str?: number | undefined;
    dex?: number | undefined;
    con?: number | undefined;
    int?: number | undefined;
    wis?: number | undefined;
    cha?: number | undefined;
    strSave?: number | undefined;
    dexSave?: number | undefined;
    conSave?: number | undefined;
    intSave?: number | undefined;
    wisSave?: number | undefined;
    chaSave?: number | undefined;
    acrobatics?: number | undefined;
    animalHandling?: number | undefined;
    arcana?: number | undefined;
    athletics?: number | undefined;
    deception?: number | undefined;
    history?: number | undefined;
    insight?: number | undefined;
    intimidation?: number | undefined;
    investigation?: number | undefined;
    nature?: number | undefined;
    medicine?: number | undefined;
    perception?: number | undefined;
    performance?: number | undefined;
    persuasion?: number | undefined;
    religion?: number | undefined;
    sleightOfHand?: number | undefined;
    stealth?: number | undefined;
    survival?: number | undefined;
    background?: string | undefined;
    race?: string | undefined;
    alignment?: string | undefined;
    xp?: string | undefined;
    age?: string | undefined;
    height?: string | undefined;
    weight?: string | undefined;
    eyes?: string | undefined;
    skin?: string | undefined;
    hair?: string | undefined;
    personality?: string | undefined;
    ideals?: string | undefined;
    bonds?: string | undefined;
    flaws?: string | undefined;
    spellAbility?: string | undefined;
    spellSaveDC?: number | undefined;
    spellAtkBonus?: number | undefined;
}

export class FeatureSkill2 implements IFeatureSkill2 {
    id!: number;
    name?: string | undefined;
    description?: string | undefined;
    level?: number | undefined;

    constructor(data?: IFeatureSkill2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.level = _data["level"];
        }
    }

    static fromJS(data: any): FeatureSkill2 {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureSkill2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["level"] = this.level;
        return data; 
    }
}

export interface IFeatureSkill2 {
    id: number;
    name?: string | undefined;
    description?: string | undefined;
    level?: number | undefined;
}

export class Weapon2 implements IWeapon2 {
    id!: number;
    name?: string | undefined;
    atkBonus?: number | undefined;
    dmg?: number | undefined;
    type?: string | undefined;

    constructor(data?: IWeapon2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.atkBonus = _data["atkBonus"];
            this.dmg = _data["dmg"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): Weapon2 {
        data = typeof data === 'object' ? data : {};
        let result = new Weapon2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["atkBonus"] = this.atkBonus;
        data["dmg"] = this.dmg;
        data["type"] = this.type;
        return data; 
    }
}

export interface IWeapon2 {
    id: number;
    name?: string | undefined;
    atkBonus?: number | undefined;
    dmg?: number | undefined;
    type?: string | undefined;
}

export class Spell2 implements ISpell2 {
    id!: number;
    name?: string | undefined;
    level?: number | undefined;
    school?: string | undefined;
    castingTime?: string | undefined;
    range?: string | undefined;
    components?: string | undefined;
    duration?: string | undefined;
    description?: string | undefined;
    higherLevels?: string | undefined;

    constructor(data?: ISpell2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.level = _data["level"];
            this.school = _data["school"];
            this.castingTime = _data["castingTime"];
            this.range = _data["range"];
            this.components = _data["components"];
            this.duration = _data["duration"];
            this.description = _data["description"];
            this.higherLevels = _data["higherLevels"];
        }
    }

    static fromJS(data: any): Spell2 {
        data = typeof data === 'object' ? data : {};
        let result = new Spell2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["level"] = this.level;
        data["school"] = this.school;
        data["castingTime"] = this.castingTime;
        data["range"] = this.range;
        data["components"] = this.components;
        data["duration"] = this.duration;
        data["description"] = this.description;
        data["higherLevels"] = this.higherLevels;
        return data; 
    }
}

export interface ISpell2 {
    id: number;
    name?: string | undefined;
    level?: number | undefined;
    school?: string | undefined;
    castingTime?: string | undefined;
    range?: string | undefined;
    components?: string | undefined;
    duration?: string | undefined;
    description?: string | undefined;
    higherLevels?: string | undefined;
}

export class ApplicationUserHeader implements IApplicationUserHeader {
    userName?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    friendRequest!: boolean;
    friends?: string[] | undefined;

    constructor(data?: IApplicationUserHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.friendRequest = _data["friendRequest"];
            if (Array.isArray(_data["friends"])) {
                this.friends = [] as any;
                for (let item of _data["friends"])
                    this.friends!.push(item);
            }
        }
    }

    static fromJS(data: any): ApplicationUserHeader {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUserHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["friendRequest"] = this.friendRequest;
        if (Array.isArray(this.friends)) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item);
        }
        return data; 
    }
}

export interface IApplicationUserHeader {
    userName?: string | undefined;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    friendRequest: boolean;
    friends?: string[] | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}